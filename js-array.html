<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<script type="text/javascript">
/*

26个API
返回Boolean：every some
返回数组：concat map slice
返回索引：indexOf lastIndexOf
返回结果：reduce reduceRight join=toString valueOf
遍历数组：forEach
操作数组：pop push unshift shift reverse splice sort

判断数组的三种方法
[].constructor.toString();//"function Array() { [native code] }".indexOf("Array") == 9
if(arr.constructor.toString().indexOf("Array") !== -1){
    //是数组
}
[].constructor === Array
[] instanceof Array
Object.prototype.toString.call([]).slice(8,-1)//"Array"
Array.isArray([])
重写
function isArray(obj) {
    return typeof obj == 'object' && obj.constructor == Array
}
*/

//1.topN排序
//字符串数组string[]，对应有一个权重数组int[]，按照如下规则取出字符串数组的top5
// 1.对数组的每个元素求综合得分，综合得分=权重得分+顺序得分，权重得分为对应权重数组的每个元素的权重值，顺序得分为字符串数组每个元素的序号数（从第一个元素开始为1,2,3,4...）。
// 2按综合得分升序排列，综合得分相同的字符串数组的元素，按原顺序从前到后排列。
// 3输出不能有多余空格、引号，大小写敏感
var strArr = ['A','B','C','D','E','F','G','H'];
var intArr = [7,5,3,2,6,1,4,9];
function topN(strArr,intArr,n){
	var score = [],scoreSort = [],len=strArr.length,index=0,result='';
	for(var i=0;i<len;i++){
		score[i] = i+1+intArr[i];
		scoreSort[i] = i+1+intArr[i];
	}
	scoreSort.sort(function(a,b){
		return a-b;
	});
	console.log(score);//[8, 7, 6, 6, 11, 7, 11, 17]
	console.log(scoreSort);//[6, 6, 7, 7, 8, 11, 11, 17]
	for(var i=0;i<n;i++){
		index=score.indexOf(scoreSort[i]);
		result += strArr[index];
		score.splice(index,1);//splice添加 删除 替换
		strArr.splice(index,1);
	}
	console.log(result);//CDBFA
	return result;
}
topN(strArr,intArr,5);

//2.数组排序
var arrNum = [32, 52, 18, 4, 10, 284, 3, 88, 7, 5];
var arrStr = ['ds','r','sv','s','vtg','n','ol','j','g','pl'];
console.log(arrStr.sort(function (a,b) {return a-b}));//"ds" "r" "sv" "s" "vtg" "n" "ol" "j" "g" "pl" 没有排序
console.log(arrStr.sort());//"ds" "g" "j" "n" "ol" "pl" "r" "s" "sv" "vtg"按照字符编码的顺序进行排序
arrNum.sort();
console.log(JSON.stringify(arrNum));//[10,18,284,3,32,4,5,52,7,88]
arrNum.sort(function(a,b){return a-b});//升序排列 [3,4,5,7,10,18,32,52,88,284]
//比较函数
var compare = function (a, b) {
    if (a < b) {
        return -1;
    } else if (a > b) {
        return 1;
    } else {
        return 0;
    }
};
var compare = function (a, b) {
    return a-b
}
arrNum.sort(compare);//升序排列

/*
动画
http://www.atool.org/sort.php
https://www.cnblogs.com/Unknw/p/6346681.html
https://www.2cto.com/kf/201609/548586.html
https://www.cnblogs.com/liyongshuai/p/7197962.html
https://www.jianshu.com/p/1b4068ccd505
*/

//3.排序算法
//3.1冒泡法（1升序2降序）
var array=[1,10,4,62,7,4,11,50,7,3,33];
function bubbleSort(array){
    var len=array.length;
    for(var i=0;i<len;i++){
        for (var j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j+1]) {        //相邻元素两两对比
                var temp = arr[j+1];        //元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return array;
}
//冒泡升序排列
function bubbleSort(arr) {
    var len = arr.length, j;
    var tempExchangVal;
    while (len > 0) {
        for (j = 0; j < len - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                tempExchangVal = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tempExchangVal;
            }
        }
        len--;
    }
    return arr;
}
bubbleSort(arrNum);
//3.2选择排序，首先在待排序序列中找到最小元素，放入储存有序序列中。同时从待排序序列中删除这个元素.
var array=[1,10,4,62,7,4,11,50,7,3,33];
function selectSort1(array){
    var newArray = [],min;
    while(array.length > 0){
        min=Math.min.apply(null,array);
        newArray.push(min);
        array.splice(array.indexOf(min),1)
    }
    return newArray;
}
function selectSort2(array){
    var newArray = [],min;
    while(array.length > 0){
        min=Math.max.apply(null,array);//扩展运算符取代apply方法 Math.max(...array)
        newArray.push(min);
        array.splice(array.indexOf(min),1)
    }
    return newArray;
}
//3.3插入排序：将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据
var array=[1,10,4,62,7,4,11,50,7,3,33];
function insertSort(array){
    for(var i=1;i<array.length;i++){
        if(array[i]<array[i-1]){
            var insert=array[i];
            var j=i-1;
            array[i]=array[j];
            while(j>=0&&insert<array[j]){
                array[j+1]=array[j];
                j--;
            }
            array[j+1]=insert;
        }
    }
    return array;
}
function insertSort(array){
    for(var i=1,j;i<array.length;i++){
        j=i;
        var v=array[j];
        while(array[j-1]>v){
            array[j]=array[j-1];
            j--;
            if(j===0){
                break;
            }
        }
        array[j]=v;
    }
    return array;
}
//3.4快速排序
function quickSort(arr){
    if(arr.length<=1)
        return arr;
    var pivotIndex = Math.floor(arr.length/2);
    //找基准，并把基准从原数组删除
    var pivot = arr.splice(pivotIndex,1)[0];
    //定义左右数组
    var left=[];
    var right=[];
    //比基准小的放在left，比基准大的放在right
    for(var i=0;i<arr.length;i++){
        if(arr[i]<=pivot){
            left.push(arr[i]);
        }
        else{
            right.push(arr[i]);
        }
    }
    //递归
    return quickSort(left).concat([pivot],quickSort(right));
}
console.log(quickSort([5,4,12,0,85,4,3,5,41,2]));//[0, 2, 3, 4, 4, 5, 5, 12, 41, 85]
function quickSort(arr){ // 从大到小
    if(arr.length <= 1){ //这个必须要，不然报堆栈溢出的错误
        return arr;
    }
    var left = [],right = [],middle = [];
    var middleValue = arr[Math.floor(arr.length / 2)];
    for(var i=0; i<arr.length; i++){
        if(arr[i] > middleValue){
            left.push(arr[i]);
        }else if(arr[i] < middleValue){
            right.push(arr[i]);
        }else{
            middle = arr[i];
        }
    }
    return [].concat(quickSort(left),middle,quickSort(right));
}

//4.对象数组排序
//按照 数字 排序
var arrObj = [
    {name:"George",age:32,birth:2014,sex:'male'},
    {name:"link",age:55,birth:1952,sex:'male'},
    {name:"wan",age:27,birth:1989,sex:'male'},
    {name:"bruce",age:44,birth:1961,sex:'male'},
    {name:"shao",age:10,birth:2006,sex:'female'},
    {name:"bob",age:1,birth:2015,sex:'female'},
    {name:"old",age:132,birth:1900,sex:'male'},
    {name:"future",age:515,birth:1800,sex:'male'},
    {name:"year",age:66,birth:1950,sex:'male'},
    {name:"www",age:100,birth:1950,sex:'female'}
];
arrObj.sort((obj1,obj2) => (obj1.age - obj2.age));
var compare = function(obj1,obj2){return obj1.age - obj2.age}
var compare = function(obj1, obj2) {
    var a = obj1.age, b = obj2.age;
    if (a > b) {
        return 1;
    }else if (a < b) {
        return -1;
    }else {
        return 0;
    }
};
arrObj.sort(compare);
//按照 属性名（Number类型） 排序
var compare = function(attrName){
        return function(obj1, obj2) {
            var a = obj1[attrName], b = obj2[attrName];
            //如果 age是 字符串 的数字 "12",需要做转换
            // if (!isNaN(Number(val1)) && !isNaN(Number(val2))) {//!isNaN(Number('111')) => true
            //     val1 = Number(val1);
            //     val2 = Number(val2);
            // }
            if (a > b) {
                return 1;
            }else if (a < b) {
                return -1;
            }else {
                return 0;
            }
        }
};
var compare = function(attrName){
        return function(obj1, obj2) {
            return obj1[attrName] - obj2[attrName]
        }
}
arrObj.sort(compare('age'));
//按照 属性名（String类型） 排序
var compare = function(attrName){
	return  function(obj1,obj2){
        var a = obj1[attrName], b = obj2[attrName];
        if (typeof obj1 === "object" && typeof obj2 === "object" && obj1 && obj2) {
            if(a === b) {
                return 0;
            }
            if(typeof a === typeof b) {
                return a < b ? -1 : 1;
            }
            return typeof a < typeof b ? -1 : 1;
        }else{
            throw ("error");
        }
    }
};
var compare = function(attrName){
    return  function(obj1,obj2){
        var a = obj1[attrName], b = obj2[attrName];
        return a > b ? 1 : -1;
    }
};
//ascii码表，0-127 十六进制字符编码：A-Z 65-90 a-z 97-122
console.log(arrObj.sort(compare('name')));//George,bob,bruce,future,link,old,shao,wan,www,year按照字符编码的顺序进行排序
//如果年龄相同，按照姓名进行排序
var compare = function(attrName01,attrName02){
    return function(obj1,obj2){
        var a = obj1[attrName01],b = obj2[attrName01];
        if(obj1 && obj2 && typeof obj1 === 'object' && typeof obj2 ==='object'){
            if(a === b){
                return typeof attrName02 === 'function' ? attrName02(obj1,obj2) : 0;
            }
            if(typeof a === typeof b){
                return a <b ? -1:1;
            }
            return typeof a < typeof b ? -1 : 1;
        }else{
            throw("error");
        }
    }
};
//age是 number类型的1  或者 string类型的'1'  都可以
var compare = function(attrName01,attrName02){
    return function(obj1,obj2){
        var a = obj1[attrName01],b = obj2[attrName01];
        if(a == b){
            return obj1[attrName02] < obj2[attrName02] ? -1 : 1;
        }else{
            return a-b
        }
    }
}
console.log(arrObj.sort(compare('age','name')));

//5.输出数组中小于等于3位数的元素，大于三位数的元素剔除
var arr = [14,1040,8,702,1,10,10,301,301,30,58,52,9100,5];
var arrThird = [];
for(var i=0,len=arr.length;i<len;i++){
    arr[i] = arr[i] + '';
    if(arr[i].length == 1){
        arrThird.push(arr[i]*100);
    }else if(arr[i].length == 2){
        arrThird.push(arr[i]*10);
    }else if(arr[i].length == 3){
        arrThird.push(Number(arr[i]));
    }else{}
}
console.log(JSON.stringify(arrThird));//[140,800,702,100,100,100,301,301,300,580,520,500]

//6.数组去重算法
//遍历数组法
var array=[1,1,1,1,10,4,62,7,4,11,50,7,3,33,3,3,3,33,7,7,7];
function delRepeat1(arr){
    var newArray = [];
    for(var i=0,len=arr.length;i<len;i++){
        if(newArray.indexOf(arr[i]) == -1){
            newArray.push(arr[i]);
        }
    }
    return newArray;
}
//数组下标判断法
function delRepeat2(arr){
    var newArray = [];
    for(var i=0;i<arr.length;i++){
        if(arr.indexOf(arr[i]) == i){
            newArray.push(arr[i]);
        }
    }
    return newArray;
}
console.log(JSON.stringify(delRepeat1(array)));//[1,10,4,62,7,11,50,3,33]
console.log(delRepeat2(array));
//对象法
function unique (arr){
    var newArr = [],obj = {};
//    for(var i = 0,len=arr.length; i < len; i++){
//        if(!obj[arr[i]]){
//            newArr.push(arr[i]);
//            obj[arr[i]] = true;
//        }
//    }
    arr.forEach((item)=>{
        if(!obj[item]){
            newArr.push(item);
            obj[item] = true;
        }
    });
    return newArr;
}
//es6
//https://segmentfault.com/a/1190000003857670?_ea=396445
//Set是一种新的数据结构，接收一个数组或者类数组对象，自动去重。一般，NaN === NaN是false，但set一样能够去重NaN
console.log(new Set([1,1,'1','1',null,null,undefined,undefined,NaN,NaN]));//Set{1,'1',null,undefined,NaN}
//Array.from将类数组对象、可遍历对象(Set/Map)转化为数组
Array.from(new Set(arr));//[1,'1',null,undefined,NaN]
Array.from(arguments);//???

//7.生成指定区间的指定数量的不重复的随机数
function arrNoRepeat(n,min,max){
    if(max - min < n)
        return
    var arr = [];
    for(var i = 0;i<n;i++){
        let tem = Math.floor(Math.random()*(max-min+1)+min);//返回介于 0（包含） ~ 1（不包含） 之间的一个随机数：
        if(arr.indexOf(tem) === -1){
            arr.push(tem)
        }else{
            i--;
        }
//        arr[i] = Math.floor(Math.random()*(max-min+1)+min);
//        if(arr.indexOf(arr[i]) !== i){
//            i--;
//        }
    }
    return arr;
}
//生成指定区间的指定数量的指定小数位数的不重复的随机数
function arrNoRepeat(n,min,max,point){
    if(max - min < n)
        return
    var arr = [];
    for(var i = 0;i<n;i++){
        arr[i] = Number((Math.random()*(max-min+1) + min).toFixed(point));
        if(arr.indexOf(arr[i]) != i){
            i--;
        }
    }
    return arr;
}

//8.输出数组两个元素和为指定数字的所有组合
//常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3)
//时间复杂度有：平方阶O(n2)
var arr = [1,3,5,2,8,13,7,23];
var sum = 10;//[3,7],][2,8]
function combina(arr,sum){
    var len=arr.length;
    for(var i=0;i<len-1;i++){
        for(var j=i+1;j<len;j++){
            if(arr[i] + arr[j] == sum){
                console.log('(' + arr[i] + ',' + arr[j] +')');
            }
        }
    }
}
//时间复杂度有：线性阶O(n)
function combina(arr,sum){
//    for(var i=0,len=arr.length;i<len;i++){
//        if(arr.indexOf(sum-arr[i]) != -1 && arr.indexOf(sum-arr[i]) > i){
//            console.log('(' + arr[i] + ',' + (sum-arr[i]) + ')');
//        }
//    }
    arr.forEach((item,index)=>{
        if(arr.indexOf(sum-item) != -1 && arr.indexOf(sum-item) > index){
            console.log('(' + item + ',' + (sum-item) + ')');
        }
    });
}
combina(arr,sum);//(3,7)(2,8)

//9.数组排序和去重
var arr = [82,24,63,45,17,31,24,50];
function unique(arr){
    var newArr = [];
    arr.sort((a,b) => (a-b));
    for(var i=0,len=arr.length;i<len;i++){
        if(newArr.indexOf(arr[i]) == -1){
            newArr.push(arr[i]);
        }
    }
    return newArr
}
console.log(unique(arr));//[17, 24, 31, 45, 50, 63, 82]

//10.给定一个整数数组，输出拼接全部元素的最小值
//[11,15,3,81,9] 11153819
var arr = [3,11,9,81,15];
for(var index in arr){
    arr[index] = arr[index] + '';
}
arr = arr.map((item)=>{
    return item+''
});
arr = arr.map(function(item,index){return item + ''});//返回处理后的数组
console.log(arr.sort().join(''));//最小值 11153819
console.log(arr.sort().reverse().join(''));//最大值 98131511
//检测数组中是否有大于15的元素


//11.数组中最大差值计算，并且最大元素的索引号 大于 最小元素的索引号
var arr = [7,8,4,9,9,3,1,10];
console.log(Math.max.apply(null,arr) - Math.min.apply(null,arr.slice(0,arr.indexOf(Math.max.apply(null,arr)))));

//12.求数组元素乘积的数组，i元素为原数组中除了下标为i的元素之外的元素乘积
//算法复杂度：时间复杂度和空间复杂度
//以平方阶O(n^2)复杂度实现 y = ax^2 + bx + c
var arr = [7,8,4,9,9,3,1,10];//[1,2,3,4,5] [120,60,40,30,24]
var multiply = [];
for(var i= 0,len=arr.length;i<len;i++){
    var newArr = (arr.slice(0,i)).concat(arr.slice(i+1));
    var multiplyIetm = 1;
    for(var index in newArr){
        multiplyIetm *= newArr[index];
    }
    multiply.push(multiplyIetm);
}
console.log(multiply);
//以线性阶O(n)复杂度实现 y = ax + b
var multiply = [];
var multiplyIetm = 1;
for(var index in arr){
    multiplyIetm *= arr[index];
}
for(var index in arr){
    multiply.push(multiplyIetm / arr[index]);
}
console.log(multiply);
//reduce 将数组元素计算为一个值（从左到右）。
arr = arr.map(function(item,index){return (arr.reduce((total,item,index)=>{return total*item}))/item})

//集合三要素：确定性 互异性-没有相同的元素 无序性
//13.求两个数组的交集、并集、补集
var arr01 = [2,4,1,11,0,89,2,12,32,44,67,11];
var arr02 = [13,2,4,1,0,98,21,23,44,67,11,2];
//交集
function crossArr(arr01,arr02){
    var cross = [];
    arr01.forEach((item,index)=>{
        if(arr02.indexOf(item) !== -1 && cross.indexOf(item) == -1){
            cross.push(item)
        }
    });
    return cross
}
console.log(crossArr(arr01,arr02));//[2, 4, 1, 11, 0, 44, 67]
//并集
function unionArr(arr01,arr02){
    var cross = [],arr = arr01.concat(arr02,arr03);
    arr.forEach((item,index)=>{
        if(arr.indexOf(item) == index){
        cross.push(item)
    }
});
    return cross
}

//14.求三个数组的交集、并集、补集
var arr01 = [2,4,1,11,0,89,2,12,32,44,67,11];
var arr02 = [13,2,4,1,0,98,21,23,44,67,11,2];
var arr03 = [2,13,0,38,38,339];
//交集
function crossArr(arr01,arr02,arr03){
    var cross = [];
    arr01.forEach((item,index)=>{
        if(arr02.indexOf(item) !== -1 && arr03.indexOf(item) !== -1 && cross.indexOf(item) == -1){
        cross.push(item)
    }
});
    return cross
}
console.log(crossArr(arr01,arr02,arr03));//[2, 21, 0, 67]
//并集
function unionArr(arr01,arr02){
    var cross = [],arr = arr01.concat(arr02);
    arr.forEach((item,index)=>{
        if(arr.indexOf(item) == index){
        cross.push(item)
    }
});
    return cross
}

//15.整型数组中乘积最大的三个数
var arr = [-10,7,29,30,5,-10,-70];
function maxMultiplu(arr){
    var len = arr.length;
    arr.sort(function(a,b){return a-b});//[-70, -10, -10, 5, 7, 29, 30]
    if(arr[0] < 0 && arr[1] < 0){
        if(arr[len-1]*arr[len-2]*arr[len-3] > arr[0]*arr[1]*arr[len-1]){
            return arr[len-1]*arr[len-2]*arr[len-3];
        }else{
            return arr[0]*arr[1]*arr[len-1];
        }
    }else{
        return arr[len-1]*arr[len-2]*arr[len-3];
    }
}
console.log(maxMultiplu(arr));//21000

//16.寻找连续数组的缺失数字
//n个连续数字的n-1个元素组成数组，已知上下边界，求以线性阶O(n)复杂度找出缺失的数字
var arr = [2,5,1,4,9,6,3,7];
var upper = 9;
var lower = 1;
var lose = 8;
for(var i=lower,len=upper-lower;i<=len;i++){
    if(arr.indexOf(i+lower) == -1){
        console.log(i+lower);
    }
}

//17.比较多选题答案，作答答案和正确答案是否一致
//引申：判断两个不重复数组是否相同
var arr01 = ['a','b'];
var arr02 = ['a','b','c'];
function compareAnswer(arr01,arr02){
    if(arr01.length !== arr02.length){
        return false;
    }
    return arr01.every(function(item01,index01){
        return arr02.some(function(item02,index02){
            return item01 === item02;
        });
    });
}
console.log(compareAnswer(arr01,arr02));//false
//every() 方法使用指定函数检测数组中的所有元素是否都符合指定条件
console.log([1,2,3].every((item) => item <= 3));//true
//some() 方法会依次执行数组的每个元素：如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。
console.log([1,2,3].some((item) => item > 3));//false

//18、数组扁平化
var arr = [1, [2, [3, 4]]];//扁平化之后：[1,2,3,4];
//递归
function flatten(arr){
    var result = [];
    arr.forEach((item,index)=>{
        if(Array.isArray(item)){
            result = result.concat(flatten(item));
        }else{
            result.push(item);
        }
    });
    return result
}

//reduce实现递归
function flatten(arr){
    return arr.reduce(function(total,item){
        return total.concat(Array.isArray(item) ? flatten(item) : item);
    },[]);//[] initialValue 传递给函数的初始值
}

function flatten(arr){
	return arr.reduce((total,item) => total.concat(Array.isArray(item) ? flatten(item) : item) ,[])
}

//toString 如果数组的元素都是数字，那么我们可以考虑使用 toString 方法，因为：toString会将数组中的数以逗号形式结合起来。
function flatten(arr){
    return arr.toString().split(',').map(function(item){
        return +item;
    })
}
//ES6扩展运算符
function flatten(arr){
    while(arr.some(item=>Array.isArray(item))){
        arr = [].concat(...arr);
    }
    return arr;
}
//
function flatten(arr){
    if(!isArray(arr) || !arr.length){
        return [];
    }else{
        return Array.prototype.concat.apply([],arr.map(function(val){
            return isArray(val) ? flatten(val) : val;
        }));
    }
    function isArray(arr){
        return Object.prototype.toString.call(arr).slice(8,-1).toLowerCase() === 'array';
    }
}
console.log(flatten(arr));//扁平化之后：[1,2,3,4]
console.log([].concat(...arr)); // [1, 2, [3, 4]]由于扩展运算符一次只能展开一层数组：因此考虑只要数组中还有数组，就使用扩展运算符展开一次。


//数组指定位置插入元素 fruits.splice(2,0,"Lemon","Kiwi");
//字符串指定位置插入元素 str = str.substring(0,i) + '' + str.substring(i);

//使用两个栈实现入队与出队
//队列(Queue)也是一种运算受限的线性表，插入只能在表的一端进行(只进不出)，而删除只能在表的另一端进行(只出不进)，允许删除的一端称为队尾(rear)，允许插入的一端称为队头 (Front),队列的操作原则是先进先出的，所以队列又称作FIFO表(First In First Out)
//栈是一种特殊的线性表。其特殊性在于限定插入和删除数据元素的操作只能在线性表的一端进行,栈的操作原则是后进先出（Last In First Out），简称为LIFO线性表。
var inputStack = [1,2,3];//First stack
var outputStack = [4,5,6];//Second stack
function enqueue(stackInput,item){
    return stackInput.push(item);
}
function dequeue(stackInput,stackOutput){
    if(stackInput.length <= 0){
        while(stackInput.length > 0){
            var elementToOutput = stackInput.pop();
            stackOutput.push(elementToOutput);
        }
    }
    return stackOutput.pop();
}

//不使用循环创建一个长度为100的数组，元素的值为它的下边
var a = new Array(100);//[undefined × 100] 长度为100的空数组
var a = Array(100).join(',').split(',').map(function(item,index){return index});

//实现乱序数组
var arr = Array(10).join(',').split(',').map(function(item,index){return index+1});
var sign = 1;
arr.sort(function(a,b){
    sign = (Math.random() > 0.5) ? 1 : -1;
    return (a-b)*sign
})

//以优雅方式求出数组的前10个元素的和
var arr = Array(100).join(',').split(',').map(function(item,index){return index+1});
var sum = arr.slice(0,10).reduce(function(pre,current){return pre+current});
console.log(sum);

//将数组中指定的两个元素放在首尾以字符串形式输出
var strArr = ['A','B','C','D','E','F']
function strSort(strArr,a,b){
    var index;
    index = strArr.indexOf(a);
    strArr.splice(index,1);
    index = strArr.indexOf(b);
    strArr.splice(index,1);
    return a + strArr.join('') + b;
}
strSort(strArr,'A','C');//ABDEFC

Array.prototype.push.apply(arr,arr1)//返回数组的长度 12

//数组最大值
var array_of_numbers = [1,5,20,12,555,18];
var biggest = Math.max.apply(Math,array_of_numbers);
//快速获取数组中的最大值最小值
var a=[1,2,3,5];
console.log(Math.max.apply(null, a));//最大值 //null表示没有对象去调用这个方法，只需要用这个方法进行运算，得到返回的结果就行
console.log(Math.min.apply(null, a));//最小值
// 多维数组可以这么修改：
var a=[1,2,3,[5,6],[1,4,8]];
var ta=a.join(",").split(",");//转化为一维数组
console.log(Math.max.apply(null,ta));//最大值
console.log(Math.min.apply(null,ta));//最小值

var arr = [1,2];
var arr2 = arr.concat();
arr2.push(arr.splice(1,0))//arr.splice(1,0) 返回一个数组，数组中的元素是被删除的元素
console.log(arr)//[1,2]
console.log(arr2)//[1,2,[]]

arr.some(function(item){return item > 15});//true false
    //数组提取元素，和字符串提取的方法相同 arr.slice();
arr.forEach(function(item,index){console.log(index,item);})//用数组的元素去做一些事情
</script>
</body>
</html>